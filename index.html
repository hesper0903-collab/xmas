<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XMAS ARCHITECT: V-MODE</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        /* --- GLOBAL & VISUALS --- */
        body { 
            margin: 0; overflow: hidden; background-color: #000; 
            font-family: 'Courier New', Courier, monospace; color: #eee; 
        }
        #webcam-video { position: absolute; width: 100vw; height: 100vh; opacity: 0; z-index: -1; pointer-events: none; }
        canvas { display: block; width: 100vw; height: 100vh; z-index: 1; }
        
        /* Background Grid */
        #grid-overlay { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; 
            background-image: linear-gradient(rgba(0, 60, 0, 0.15) 1px, transparent 1px), linear-gradient(90deg, rgba(0, 60, 0, 0.15) 1px, transparent 1px);
            background-size: 40px 40px; mask-image: radial-gradient(circle at center, black 40%, transparent 100%);
        }
        /* Scanline */
        #scanline {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 20; pointer-events: none;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.05) 50%, rgba(0,0,0,0.05));
            background-size: 100% 3px; opacity: 0.3;
        }

        /* --- UI LAYOUT --- */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; padding: 30px; box-sizing: border-box; pointer-events: none; }
        .hud-container { pointer-events: auto; position: absolute; top: 30px; left: 30px; display: flex; flex-direction: column; gap: 25px; text-transform: uppercase; letter-spacing: 1px; text-shadow: 0 0 5px rgba(0,255,0,0.5); }
        h1.main-title { font-size: 36px; margin: 0; font-weight: 800; line-height: 0.9; color: #fff; letter-spacing: 2px; }
        .section-label { font-size: 10px; color: #0a0; margin-bottom: 5px; font-weight: bold; border-bottom: 1px solid #0a0; display: inline-block; padding-bottom: 2px;}
        .current-projection { font-size: 28px; font-weight: bold; color: #fff; margin: 0; }
        .status-list { list-style: none; padding: 0; margin: 0; font-size: 12px; font-weight: bold; color: #444; }
        .status-list li { margin-bottom: 8px; display: flex; align-items: center; transition: color 0.3s; }
        .indicator { width: 6px; height: 6px; background-color: #222; margin-right: 12px; box-shadow: 0 0 0px transparent; transition: all 0.3s; }
        .active-state { color: #fff !important; }
        
        /* Indicators Colors */
        .ind-green { background-color: #0f0; box-shadow: 0 0 8px #0f0; }
        .ind-cyan { background-color: #0ff; box-shadow: 0 0 8px #0ff; }
        .ind-red { background-color: #f00; box-shadow: 0 0 10px #f00; transform: scale(1.5); }
        .ind-gold { background-color: #ffd700; box-shadow: 0 0 8px #ffd700; } /* V-Gesture Color */

        .real-time-data { display: grid; grid-template-columns: 1fr 1fr; gap: 15px 40px; font-size: 12px; color: #0a0; }
        .data-item span { display: block; font-size: 14px; font-weight: bold; color: #eee; margin-top: 2px; }
        #fs-btn {
            pointer-events: auto; position: absolute; bottom: 30px; right: 30px;
            background: transparent; border: 1px solid #0f0; color: #0f0;
            padding: 10px 20px; font-family: 'Courier New', monospace; font-weight: bold; cursor: pointer;
            text-transform: uppercase; letter-spacing: 2px; transition: all 0.3s; font-size: 12px;
        }
        #fs-btn:hover { background: rgba(0, 255, 0, 0.2); box-shadow: 0 0 15px #0f0; }
        #loader { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 100; display: flex; justify-content: center; align-items: center; flex-direction: column; }
        .loader-text { margin-top: 20px; color: #0f0; animation: blink 0.5s infinite alternate; }
        @keyframes blink { from { opacity: 1; } to { opacity: 0.3; } }
        .lil-gui.root { position: absolute; top: 30px; right: 30px; pointer-events: auto; }
        .lil-gui { --background-color: rgba(0,20,0,0.8); --text-color: #0f0; --title-background-color: #000; --widget-color: #030; --hover-color: #050; --focus-color: #070; --number-color: #0f0; --string-color: #0f0; border: 1px solid #050; }
        .lil-gui .title { border-bottom: 1px solid #050; color: #fff; }
    </style>
</head>
<body>
    <video id="webcam-video" playsinline></video>
    <div id="grid-overlay"></div><div id="scanline"></div>
    <canvas id="output-canvas"></canvas>
    <div id="loader"><h1 style="font-size: 40px; letter-spacing: 5px; color: #fff;">XMAS ARCHITECT</h1><div class="loader-text">> INITIALIZING SENSOR ARRAY...</div></div>
    <div id="ui-layer">
        <div class="hud-container">
            <div><h1 class="main-title">XMAS<br>ARCHITECT</h1></div>
            <div><div class="section-label">CURRENT FORM</div><h2 class="current-projection" id="projection-name">NEON TREE</h2></div>
            <div><div class="section-label">SENSOR STATUS</div>
                <ul class="status-list">
                    <li id="li-cam"><div class="indicator" id="ind-cam"></div>CAM FEED</li>
                    <li id="li-track"><div class="indicator" id="ind-track"></div>HAND TRACK</li>
                    <li id="li-pinch"><div class="indicator" id="ind-pinch"></div>PINCH LOCK (360° DRAG)</li>
                    <li id="li-victory"><div class="indicator" id="ind-victory"></div>V-MODE (AUTO SPIN)</li>
                    <li id="li-fist"><div class="indicator" id="ind-fist"></div>FIST MORPH (NEXT)</li>
                </ul>
            </div>
            <div><div class="section-label">TELEMETRY</div>
                <div class="real-time-data"><div class="data-item">PARTICLES<span id="particle-count">0</span></div><div class="data-item">FPS<span id="fps-counter">0</span></div><div class="data-item">RUNTIME<span id="time-counter">00:00:00</span></div></div>
            </div>
        </div>
        <button id="fs-btn">[ ] ENTER IMMERSION</button>
    </div>

    <script type="importmap">{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/", "lil-gui": "https://unpkg.com/lil-gui@0.19.1/dist/lil-gui.esm.min.js" } }</script>

    <script type="module">
        import * as THREE from 'three';
        import GUI from 'lil-gui';

        // --- CONFIGURATION ---
        const CONFIG = {
            particleCount: 9000, 
            particleSize: 0.18,  
            scatterSpeed: 0.12, 
            rotationSpeed: 0.8, // 基础转速
            dragSensitivity: 0.3, 
            modelScale: 1.0,    
            distortion: 0.005,  
            repulseRadius: 20.0,
            repulseForce: 1.5,
            showSkeleton: true,
            colors: [0xff0000, 0x00ff00, 0x00ffff, 0xffff00],
            trunkColor: 0x8B4513,
            snowWhite: 0xffffff,
            armBrown: 0xA0522D,
            faceBlack: 0x111111,
            candyRed: 0xFF0000,
            candyWhite: 0xFFFFFF
        };

        const SHAPES = ['NEON TREE', 'SNOWMAN', 'GIFT BOX', 'CANDY CANE'];
        let currentShapeIndex = 0; 

        let scene, camera, renderer, clock;
        let particleSystem, geometry, material;
        let particlesData = []; 
        let handMesh, handJoints;
        let handLandmarksRaw = null;
        let rotationGroup; 
        let neonTexture, techJointTexture;
        
        // 交互状态
        let isPinching = false;
        let isFist = false;
        let isVictory = false; // 新增状态
        let lastFistTime = 0;
        
        // 拖拽旋转逻辑变量
        let previousHandX = 0;
        let previousHandY = 0; 
        let wasPinching = false;

        const videoElement = document.getElementById('webcam-video');
        const loader = document.getElementById('loader');
        const projNameEl = document.getElementById('projection-name');
        
        function createSharpNeonTexture() {
            const canvas = document.createElement('canvas'); const size = 128; canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(size/2, size/2, size/10, size/2, size/2, size/2);
            grad.addColorStop(0, 'rgba(255, 255, 255, 1)');     
            grad.addColorStop(0.3, 'rgba(255, 255, 255, 0.9)'); 
            grad.addColorStop(0.6, 'rgba(255, 255, 255, 0.2)'); 
            grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = grad; ctx.fillRect(0, 0, size, size);
            return new THREE.CanvasTexture(canvas);
        }

        function createTechJointTexture() {
            const canvas = document.createElement('canvas'); const size = 64; canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0,0,size,size);
            ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 4;
            ctx.beginPath(); ctx.arc(size/2, size/2, size/2-4, 0, Math.PI*2); ctx.stroke();
            ctx.fillStyle = '#ffffff'; ctx.beginPath(); ctx.arc(size/2, size/2, 6, 0, Math.PI*2); ctx.fill();
            return new THREE.CanvasTexture(canvas);
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000); 
            scene.fog = new THREE.FogExp2(0x000000, 0.02);
            clock = new THREE.Clock();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 14; 
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('output-canvas'), alpha: false, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            rotationGroup = new THREE.Group();
            scene.add(rotationGroup);

            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(CONFIG.particleCount * 3);
            const colors = new Float32Array(CONFIG.particleCount * 3);
            const sizes = new Float32Array(CONFIG.particleCount);
            particlesData = [];
            neonTexture = createSharpNeonTexture();

            for (let i = 0; i < CONFIG.particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 60; positions[i * 3 + 1] = (Math.random() - 0.5) * 60; positions[i * 3 + 2] = (Math.random() - 0.5) * 60;
                colors[i * 3] = 1; colors[i * 3 + 1] = 1; colors[i * 3 + 2] = 1;
                sizes[i] = Math.random() * 0.5 + 0.5;
                particlesData.push({ targetX: 0, targetY: 0, targetZ: 0, vx: 0, vy: 0, vz: 0, baseX:0, baseY:0, baseZ:0 });
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            material = new THREE.PointsMaterial({
                size: CONFIG.particleSize, vertexColors: true, map: neonTexture,
                transparent: true, opacity: 1.0, blending: THREE.AdditiveBlending, depthWrite: false, sizeAttenuation: true
            });
            particleSystem = new THREE.Points(geometry, material);
            rotationGroup.add(particleSystem);

            techJointTexture = createTechJointTexture();
            const skelMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 1.0, linewidth: 1, depthTest: false });
            handMesh = new THREE.LineSegments(new THREE.BufferGeometry(), skelMat);
            handMesh.renderOrder = 999; scene.add(handMesh);

            const jointMat = new THREE.PointsMaterial({
                color: 0xffffff, size: 0.35, map: techJointTexture,
                transparent: true, opacity: 1.0, blending: THREE.AdditiveBlending, depthTest: false
            });
            handJoints = new THREE.Points(new THREE.BufferGeometry().setAttribute('position', new THREE.BufferAttribute(new Float32Array(21 * 3), 3)), jointMat);
            handJoints.renderOrder = 1000; scene.add(handJoints);

            document.getElementById('fs-btn').addEventListener('click', () => {
                if (!document.fullscreenElement) { document.documentElement.requestFullscreen(); document.getElementById('fs-btn').innerText = "[ ] EXIT IMMERSION"; }
                else { document.exitFullscreen(); document.getElementById('fs-btn').innerText = "[ ] ENTER IMMERSION"; }
            });
            generateShape(SHAPES[0]); setupGUI(); window.addEventListener('resize', onWindowResize); animate(); initMediaPipe();
        }

        // --- SHAPE MATH ---
        function generateShape(type) {
            const count = CONFIG.particleCount;
            const colorsAttr = geometry.attributes.color;
            const tempColor = new THREE.Color();

            for (let i = 0; i < count; i++) {
                let x, y, z; 
                
                if (type === 'NEON TREE') {
                    const trunkRatio = 0.1;
                    if (i < count * trunkRatio) { 
                        const h = 3.5; const r = 0.7; y = (Math.random() - 0.5) * h - 5.5;
                        const angle = Math.random() * 6.28; x = Math.cos(angle) * r * Math.sqrt(Math.random()); z = Math.sin(angle) * r * Math.sqrt(Math.random());
                        tempColor.setHex(CONFIG.trunkColor);
                    } else { 
                        const h = 11; const yNorm = Math.random(); y = (yNorm - 0.5) * h + 1;
                        const rBase = (1 - yNorm) * 5.5; const angle = yNorm * 25 + Math.random() * 6.28;
                        x = Math.cos(angle) * rBase * (0.7 + Math.random()*0.3); z = Math.sin(angle) * rBase * (0.7 + Math.random()*0.3);
                        const distFromCenter = Math.sqrt(x*x + z*z) / rBase;
                        tempColor.setHex(CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)]);
                        const brightness = (0.5 + (y + 5) / 15 * 0.8) * (1.2 - distFromCenter * 0.5); 
                        tempColor.multiplyScalar(brightness);
                    }
                } 
                else if (type === 'SNOWMAN') {
                    const r = Math.random();
                    if (i < 150) { 
                        const isEye = i < 60;
                        const theta = isEye ? (i<30 ? -0.5 : 0.5) : (Math.random()-0.5)*1.2; 
                        const phi = isEye ? 1.2 : 1.8; 
                        const rad = 1.7; const cy = 4.2;
                        x = rad * Math.sin(phi) * Math.sin(theta); y = rad * Math.cos(phi) + cy; z = rad * Math.sin(phi) * Math.cos(theta);
                        tempColor.setHex(CONFIG.faceBlack);
                    } else if (i < 400) { 
                        const side = i < 275 ? 1 : -1; const t = Math.random();
                        x = side * (2.0 + t * 3.0); y = 1.0 + t * 2.0 + (Math.random()-0.5)*0.5; z = (Math.random()-0.5)*0.5;
                        tempColor.setHex(CONFIG.armBrown);
                    } else { 
                        let rad, cy; if(r<0.35){rad=3.2;cy=-3.8;}else if(r<0.7){rad=2.3;cy=0.8;}else{rad=1.6;cy=4.2;}
                        const phi=Math.acos(2*Math.random()-1); const theta=Math.random()*6.28; const rDist=rad*Math.pow(Math.random(),1/3);
                        x=rDist*Math.sin(phi)*Math.cos(theta); y=rDist*Math.sin(phi)*Math.sin(theta)+cy; z=rDist*Math.cos(phi);
                        tempColor.setHex(CONFIG.snowWhite);
                        tempColor.multiplyScalar(0.9 + Math.random()*0.3);
                    }
                } 
                else if (type === 'GIFT BOX') {
                    const s = 6.0; 
                    if (i < count * 0.9) {
                        x=(Math.random()-0.5)*s; y=(Math.random()-0.5)*s; z=(Math.random()-0.5)*s;
                        if(Math.random()>0.3) { 
                             const dim = Math.floor(Math.random()*3); if(dim===0)x=Math.sign(x)*s/2; else if(dim===1)y=Math.sign(y)*s/2; else z=Math.sign(z)*s/2; 
                        }
                        tempColor.setHex(CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)]);
                    } else {
                        const t = Math.random() * Math.PI * 2;
                        const bowSize = 2.5; 
                        x = Math.sin(t) * bowSize * (Math.cos(t)*0.5 + 1); 
                        z = Math.cos(t) * Math.sin(t) * bowSize; 
                        y = s/2 + 0.5 + Math.random()*1.0; 
                        tempColor.setHex(CONFIG.candyRed);
                        tempColor.multiplyScalar(1.5); 
                    }
                } 
                else if (type === 'CANDY CANE') {
                    const t=Math.random(); const totalLen=16; const straightLen=10; const cur=t*totalLen;
                    const tubeRad=1.0; const ang=Math.random()*6.28; const r=Math.sqrt(Math.random())*tubeRad;
                    const cx=Math.cos(ang)*r; const cz=Math.sin(ang)*r;
                    if(cur<straightLen) { x=cx; y=cur-totalLen/2-1; z=cz; } 
                    else { const hookRad=2.8; const hookAngle=((cur-straightLen)/(totalLen-straightLen))*Math.PI; const cy=straightLen-totalLen/2-1; x=(hookRad+cx)*Math.cos(hookAngle)+hookRad; y=(hookRad+cx)*Math.sin(hookAngle)+cy; z=cz; }
                    
                    const stripeFreq = 3.0; 
                    const pattern = (cur / totalLen * stripeFreq + ang / (Math.PI*2)) % 1.0;
                    tempColor.setHex(pattern < 0.5 ? CONFIG.candyRed : CONFIG.candyWhite);
                    if (pattern >= 0.5) tempColor.multiplyScalar(1.2);
                }
                
                particlesData[i].baseX = x; particlesData[i].baseY = y; particlesData[i].baseZ = z;
                colorsAttr.setXYZ(i, tempColor.r, tempColor.g, tempColor.b);
            }
            colorsAttr.needsUpdate = true;
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta(); const time = clock.getElapsedTime();
            const d = new Date(time * 1000); document.getElementById('time-counter').innerText = d.toISOString().substr(11, 8);
            document.getElementById('particle-count').innerText = CONFIG.particleCount; document.getElementById('fps-counter').innerText = Math.round(1/delta)||60;

            let handPos = null;
            if (handLandmarksRaw && CONFIG.showSkeleton) {
                const palm = handLandmarksRaw[9]; handPos = new THREE.Vector3((0.5-palm.x)*30, (0.5-palm.y)*25, 0);
            }
            
            // --- 旋转控制逻辑 ---
            if (handPos && isPinching) {
                // 1. 优先：捏合拖拽 (360度自由旋转)
                if (!wasPinching) {
                    previousHandX = handPos.x;
                    previousHandY = handPos.y; 
                    wasPinching = true;
                } else {
                    const deltaX = handPos.x - previousHandX;
                    const deltaY = handPos.y - previousHandY;
                    rotationGroup.rotation.y += deltaX * CONFIG.dragSensitivity; 
                    rotationGroup.rotation.x += deltaY * CONFIG.dragSensitivity;
                    previousHandX = handPos.x;
                    previousHandY = handPos.y;
                }
            } else if (isVictory) {
                // 2. 其次：比耶 (自动水平旋转，速度0.8)
                wasPinching = false;
                // 顺时针旋转 Y 轴，速度约为 0.8 rad/s (调节系数适配帧率)
                rotationGroup.rotation.y -= 0.05 * delta * 16; // 0.05 * 16 = 0.8
                // 自动回正 X 轴倾斜
                rotationGroup.rotation.x *= 0.9;
            } else {
                // 3. 最后：闲置 (极慢速转动)
                wasPinching = false;
                rotationGroup.rotation.y -= 0.1 * delta * CONFIG.rotationSpeed;
                rotationGroup.rotation.x *= 0.95; 
            }

            rotationGroup.scale.setScalar(CONFIG.modelScale);
            material.size = CONFIG.particleSize * CONFIG.modelScale;

            const positions = geometry.attributes.position.array;
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const data = particlesData[i]; const px = positions[i*3]; const py = positions[i*3+1]; const pz = positions[i*3+2];
                const nx = Math.sin(time+data.baseY)*CONFIG.distortion; const ny = Math.cos(time+data.baseX)*CONFIG.distortion;
                data.targetX = data.baseX + nx; data.targetY = data.baseY + ny; data.targetZ = data.baseZ;
                const dx = data.targetX - px; const dy = data.targetY - py; const dz = data.targetZ - pz;
                data.vx += dx*CONFIG.scatterSpeed*60*delta; data.vy += dy*CONFIG.scatterSpeed*60*delta; data.vz += dz*CONFIG.scatterSpeed*60*delta;
                if (handPos) {
                    const dx = px - handPos.x; const dy = py - handPos.y; const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 5.0) { 
                        const force = (5.0 - dist) * CONFIG.repulseForce * delta * 20;
                        data.vx += (dx/dist)*force; data.vy += (dy/dist)*force; data.vz += (Math.random()-0.5)*force;
                    }
                }
                data.vx *= 0.9; data.vy *= 0.9; data.vz *= 0.9;
                positions[i*3] += data.vx; positions[i*3+1] += data.vy; positions[i*3+2] += data.vz;
            }
            geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }

        function detectGestures(landmarks) {
            if (!landmarks) { 
                isPinching=false; isFist=false; isVictory=false;
                uiState('track',false); uiState('pinch',false); uiState('fist',false); uiState('victory', false);
                return; 
            }
            uiState('track', true);

            // 1. Pinch Detection
            const dPinch = Math.hypot(landmarks[4].x-landmarks[8].x, landmarks[4].y-landmarks[8].y);
            if (dPinch < 0.05) { isPinching = true; uiState('pinch', true); } else { isPinching = false; uiState('pinch', false); }

            // 2. Fist Detection
            const tips=[8,12,16,20]; const wrist=landmarks[0]; let dFist=0; tips.forEach(i=>dFist+=Math.hypot(landmarks[i].x-wrist.x, landmarks[i].y-wrist.y)); dFist/=4;
            if (dFist < 0.15) {
                if(!isFist && Date.now()-lastFistTime>1000) { triggerNext(); lastFistTime=Date.now(); uiState('fist', true); setTimeout(()=>uiState('fist', false), 300); }
                isFist = true;
            } else { isFist = false; }

            // 3. Victory (V-Sign) Detection
            // 简单判断：食指(8)和中指(12)伸直，无名指(16)和小指(20)弯曲
            // 判定伸直/弯曲：指尖到手腕距离
            const distWrist = (idx) => Math.hypot(landmarks[idx].x - landmarks[0].x, landmarks[idx].y - landmarks[0].y);
            const dIndex = distWrist(8);
            const dMid = distWrist(12);
            const dRing = distWrist(16);
            const dPinky = distWrist(20);
            
            // 阈值判断：食指中指远离手腕，无名小指靠近手腕
            if (dIndex > 0.25 && dMid > 0.25 && dRing < 0.2 && dPinky < 0.2 && !isPinching && !isFist) {
                isVictory = true;
                uiState('victory', true);
            } else {
                isVictory = false;
                uiState('victory', false);
            }
        }
        function triggerNext() {
            currentShapeIndex = (currentShapeIndex+1)%SHAPES.length; projNameEl.innerText = SHAPES[currentShapeIndex];
            generateShape(SHAPES[currentShapeIndex]);
            particlesData.forEach(p => { p.vx+=(Math.random()-0.5)*10; p.vy+=(Math.random()-0.5)*10; p.vz+=(Math.random()-0.5)*10; });
        }
        function uiState(id, active) {
            const ind=document.getElementById('ind-'+id); const li=document.getElementById('li-'+id);
            if(active) { 
                li.classList.add('active-state'); 
                if(id==='cam' || id==='track') ind.classList.add('ind-green'); 
                if(id==='pinch') ind.classList.add('ind-cyan'); 
                if(id==='fist') ind.classList.add('ind-red'); 
                if(id==='victory') ind.classList.add('ind-gold'); 
            }
            else { li.classList.remove('active-state'); ind.className='indicator'; }
        }
        function initMediaPipe() {
            const hands = new window.Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({maxNumHands:1, modelComplexity:1, minDetectionConfidence:0.6, minTrackingConfidence:0.6});
            hands.onResults(results => {
                if(results.multiHandLandmarks && results.multiHandLandmarks.length>0) { handLandmarksRaw=results.multiHandLandmarks[0]; detectGestures(handLandmarksRaw); if(CONFIG.showSkeleton) drawSkeleton(handLandmarksRaw); else { handMesh.visible=false; handJoints.visible=false; } }
                else { handLandmarksRaw=null; handMesh.visible=false; handJoints.visible=false; detectGestures(null); }
            });
            const cam = new window.Camera(videoElement, { onFrame: async()=>{ await hands.send({image: videoElement}); }, width:1280, height:720 });
            cam.start().then(()=>{ loader.style.display='none'; uiState('cam', true); });
        }
        function drawSkeleton(lm) {
            const linePoints=[]; 
            const pairs=[[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[0,9],[9,10],[10,11],[11,12],[0,13],[13,14],[14,15],[15,16],[0,17],[17,18],[18,19],[19,20]];
            pairs.push([5,9], [9,13], [13,17]); 
            pairs.forEach(p=>{ linePoints.push((0.5-lm[p[0]].x)*30,(0.5-lm[p[0]].y)*25,0); linePoints.push((0.5-lm[p[1]].x)*30,(0.5-lm[p[1]].y)*25,0); });
            handMesh.geometry.setAttribute('position', new THREE.Float32BufferAttribute(linePoints, 3)); handMesh.visible = true;
            const jointPoints=[]; lm.forEach(p=>{ jointPoints.push((0.5-p.x)*30,(0.5-p.y)*25,0); });
            handJoints.geometry.setAttribute('position', new THREE.Float32BufferAttribute(jointPoints, 3)); handJoints.visible = true;
        }
        function setupGUI() {
            const gui = new GUI({title: 'SYSTEM CONTROL'});
            gui.add(CONFIG, 'rotationSpeed', 0, 2.0).name('SPIN RATE'); gui.add(CONFIG, 'modelScale', 0.5, 2.0).name('HOLOGRAM SCALE'); gui.add(CONFIG, 'scatterSpeed', 0.01, 0.5).name('PARTICLE DENSITY'); gui.add(CONFIG, 'showSkeleton').name('HAND TRACK VIS');
        }
        function onWindowResize() { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        init();
    </script>
</body>
</html>
